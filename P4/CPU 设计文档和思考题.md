# CPU 设计文档和思考题

## CPU设计文档

1. 顶层设计
   	在logisim搭建的CPU中，将包含IFU，Splitter，Controller，GRF，ALU，DM，EXT。在其中进行合理的电路连接后，能够使其拥有解析指令的能力，完成单周期CPU。利用一个包含Controller的Control Unit来连接各个结构的输入端口和输出端口。

2. IFU

   - 可以使用多路选择器进行赋初值和异步复位

   - 使用寄存器实现PC，使用ROM实现

     | 端口名 | I/O  | 位宽 | 用处                 |
     | :----: | :--: | :--: | :------------------- |
     |  clk   |  I   |  1   | 时钟信号             |
     | reset  |  I   |  1   | 异步复位信号         |
     |  pcIn  |  I   |  32  | 计数器信号，用于写入 |
     | pcOut  |  O   |  32  | 计数器信号，用于输出 |
     | Instr  |  O   |  32  | 输出的指令           |
3. GRF

   - 32个寄存器，0号寄存器始终保持0，其余复位后均为0
   - 实现异步复位
     | 端口名 | I/O  | 位宽 | 用处                                        |
     | :----: | :--: | :--: | :------------------------------------------ |
     |  clk   |  I   |  1   | 时钟信号                                    |
     | reset  |  I   |  1   | 异步复位信号                                |
     |   WE   |  I   |  1   | 1表示可以向GRF中写入数据WD<br />0表示不写入 |
     |   A1   |  I   |  5   | 把A1寄存器的值读入RD1                       |
     |   A2   |  I   |  5   | 把A2寄存器的值读入RD2                       |
     |   A3   |  I   |  5   | 写入端口                       |
     |   WD   |  I   |  32  | 写入的数据                                  |
     |  RD1   |  O   |  32  | 输出RD1                                     |
     |  RD2   |  O   |  32  | 输出RD2                                     |
4. ALU

   - 提供加减乘除，位运算，大小比较和移位等运算
     
   - 这里考虑到ALU的可拓展性，Op选取了4位
     
     | 端口名 | I/O  | 位宽 | 用处     |
     | :----: | :--: | :--: | :------- |
     |   Op   |  I   |  8   | 操作类型 |
     |   I1   |  I   |  32  | 数据1    |
     |   I2   |  I   |  32  | 数据2    |
     |   O    |  O   |  32  | 运算结果 |
     
     | 操作名字 |  Op  |
     | :------: | :--: |
     |    +     |  0   |
     |    -     |  1   |
     |    \|     |  2   |
     |    ==     |  3   |
     |    >    |  4   |
     |    <<     |  5   |


5. DM

   - 实现异步复位

   - 加入写入和读取数据功能

   - 用12位来访问地址

     | 端口名 | I/O  | 位宽 |            用处            |
     | :----: | :--: | :--: | :------------------------- |
     |  clk   |  I   |  1   |          时钟信号          |
     | reset  |  I   |  1   |        异步复位信号        |
     |   WE   |  I   |  1   | 1表示可以向GRF中写入数据WD |
     |  WD   |  I   |  32  |          输入数据          |
     |   addr   |  I   |  32   |   访问的位置   |
     |  RD   |  O   |  32  |          输出数据           |

6. EXT

   - 将16位数据扩展到32位，实现0扩展和符号扩展

     | 端口名 | I/O  | 位宽 |      用处      |
     | :----: | :--: | :--: | :------------- |
     | Input |  I   |  16  | 输入的16位数据 |
     | EXTOp | I | 2 | 判断扩展类型<br />0为0扩展<br />1为符号扩展<br />2为左移16位 |
     | Output | O | 32 | 输出的32位数据 |

7. NPC

   - 作为PC的状态转移

     | 端口名 | I/O  | 位宽 |   用处   |
     | :----: | :--: | :--: | :------: |
     |   PC   |  I   |  32  |  当前PC  |
     |   Op   |  I   |  2   | 转换类型 |
     | PCNext |  O   |  32  | 下一个PC |


8. Controller

   - 获取Instr的前6位信号和后6位信号，输出操作类型

   - 先通过和逻辑来实现指令的判断，再通过或逻辑来生成操作
   
     |   端口名   | I/O  | 位宽 | 用处                                  |
     | :--------: | :--: | :--: | :------------------------------------ |
     |     Op     |  I   |  6   | 操作名                                |
     |    func    |  I   |  6   | R指令操作类型                         |
     |   RegDst   |  O   |  2   | 写入寄存器的位置<br />0表示16-20(I型)<br />1表示11-15(R型)<br />2表示$31(Jal) |
     |   ALUSrc   |  O   |  1   | 0表示ALU加寄存器的数<br />1表示立即数 |
     | RegSrc |  O   |  2   | 寄存器读写内存的值<br />0为ALU结果<br />1为Mem结果<br />2为PC的值 |
     | RegWrite |  O   |  1   | 寄存器读写<br />1表示可以写入         |
     |   MemWrite    |  O   |  1   | 内存读写<br />1表示可以写入           |
     |  nPC_sel  |  O   |  2   | 0表示PC直接加4<br />1表示PC加offset<br />2表示使用Instr_index<br />3表示使用寄存器的值 |
     |   EXTOp   |  O   |  2   | 扩展类型                              |
     |   ALUOp    |  O   |  8   | ALU操作                           |
     





## 测试方案

利用MARS构造样例，利用mips的逐行调试功能对比仿真过程中输出的结果对比来判断正确性。

## 思考题

1. 由ALU的输出取[11:2]位后取得的

   在实际的CPU中，DM是8bit为单位的，存一个字需要4个寄存器，位数为[11:2]更符合实际情况

2. 第一种

   ```
   RegWrite = (Operation == ADD) | (Operation == SUB) | (Operation == SLL);
   ```

   第二种

   ```
   `fADD: begin
   	RegDst = `RD;
   	ALUSrc = `GRFmem;
   	RegSrc = `ALUOut;
   	RegWrite = `YES;
   	MemWrite = `NO;
   	nPC_sel = `Next;
   	EXTOp = `zeroExtend;
   	ALUOp = `Add;
   end
   ```

   第一种方法减少了运算器的使用，可扩展性强；第二种方法比较直观，方便debug

3. 在同步复位中，需要在时钟周期的上升沿进行复位，clk优先级高

   在异步复位中，只要reset置1即可复位，reset优先级高

4. ADD/ADDI指令溢出是由于计算后溢出出现了1，并且ALU会输出一个溢出flag，在不输出溢出信号的情况下，ADD/ADDI和ADDU/ADDIU没有其他计算上的区别。
