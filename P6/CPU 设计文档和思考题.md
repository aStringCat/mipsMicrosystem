# CPU 设计文档和思考题

## CPU设计文档

1. 顶层设计
   	在logisim搭建的CPU中，将包含IFU，Splitter，Controller，GRF，ALU，DM，EXT。在其中进行合理的电路连接后，能够使其拥有解析指令的能力，完成单周期CPU。利用一个包含Controller的Control Unit来连接各个结构的输入端口和输出端口。

2. IFU

   - 可以使用多路选择器进行赋初值和异步复位

   - 使用寄存器实现PC，使用ROM实现

     | 端口名 | I/O  | 位宽 | 用处                 |
     | :----: | :--: | :--: | :------------------- |
     |  clk   |  I   |  1   | 时钟信号             |
     | reset  |  I   |  1   | 异步复位信号         |
     |  pcIn  |  I   |  32  | 计数器信号，用于写入 |
     | pcOut  |  O   |  32  | 计数器信号，用于输出 |
     | Instr  |  O   |  32  | 输出的指令           |
3. GRF

   - 32个寄存器，0号寄存器始终保持0，其余复位后均为0
   - 实现异步复位
     | 端口名 | I/O  | 位宽 | 用处                                        |
     | :----: | :--: | :--: | :------------------------------------------ |
     |  clk   |  I   |  1   | 时钟信号                                    |
     | reset  |  I   |  1   | 异步复位信号                                |
     |   WE   |  I   |  1   | 1表示可以向GRF中写入数据WD<br />0表示不写入 |
     |   A1   |  I   |  5   | 把A1寄存器的值读入RD1                       |
     |   A2   |  I   |  5   | 把A2寄存器的值读入RD2                       |
     |   A3   |  I   |  5   | 写入端口                       |
     |   WD   |  I   |  32  | 写入的数据                                  |
     |  RD1   |  O   |  32  | 输出RD1                                     |
     |  RD2   |  O   |  32  | 输出RD2                                     |
4. ALU

   - 提供加减乘除，位运算，大小比较和移位等运算
     
   - 这里考虑到ALU的可拓展性，Op选取了4位
     
     | 端口名 | I/O  | 位宽 | 用处     |
     | :----: | :--: | :--: | :------- |
     |   Op   |  I   |  8   | 操作类型 |
     |   I1   |  I   |  32  | 数据1    |
     |   I2   |  I   |  32  | 数据2    |
     |   O    |  O   |  32  | 运算结果 |
     
     | 操作名字 |  Op  |
     | :------: | :--: |
     |    +     |  0   |
     |    -     |  1   |
     |    \|     |  2   |
     |    <    |  3   |


5. DM

   - 实现异步复位

   - 加入写入和读取数据功能

   - 用12位来访问地址

     | 端口名 | I/O  | 位宽 |            用处            |
     | :----: | :--: | :--: | :------------------------- |
     |  clk   |  I   |  1   |          时钟信号          |
     | reset  |  I   |  1   |        异步复位信号        |
     |   WE   |  I   |  1   | 1表示可以向GRF中写入数据WD |
     |  WD   |  I   |  32  |          输入数据          |
     |   addr   |  I   |  32   |   访问的位置   |
     |  RD   |  O   |  32  |          输出数据           |

6. EXT

   - 将16位数据扩展到32位，实现0扩展和符号扩展

     | 端口名 | I/O  | 位宽 |      用处      |
     | :----: | :--: | :--: | :------------- |
     | Input |  I   |  16  | 输入的16位数据 |
     | EXTOp | I | 2 | 判断扩展类型<br />0为0扩展<br />1为符号扩展<br />2为左移16位 |
     | Output | O | 32 | 输出的32位数据 |

7. NPC

   - 作为PC的状态转移

     | 端口名 | I/O  | 位宽 |   用处   |
     | :----: | :--: | :--: | :------: |
     |   PC   |  I   |  32  |  当前PC  |
     |   Op   |  I   |  2   | 转换类型 |
     | PCNext |  O   |  32  | 下一个PC |


8. Controller

   - 获取Instr的前6位信号和后6位信号，输出操作类型

   - 先通过和逻辑来实现指令的判断，再通过或逻辑来生成操作
   
     |   端口名   | I/O  | 位宽 | 用处                                  |
     | :--------: | :--: | :--: | :------------------------------------ |
     |     Op     |  I   |  6   | 操作名                                |
     |    func    |  I   |  6   | R指令操作类型                         |
     |   RegDst   |  O   |  2   | 写入寄存器的位置<br />0表示16-20(I型)<br />1表示11-15(R型)<br />2表示$31(Jal) |
     |   ALUSrc   |  O   |  1   | 0表示ALU加寄存器的数<br />1表示立即数 |
     | RegSrc |  O   |  2   | 寄存器读写内存的值<br />0为ALU结果<br />1为Mem结果<br />2为PC的值 |
     | RegWrite |  O   |  1   | 寄存器读写<br />1表示可以写入         |
     |   MemWrite    |  O   |  1   | 内存读写<br />1表示可以写入           |
     |  NPCOp  |  O   |  2   | 0表示PC直接加4<br />1表示PC加offset<br />2表示使用Instr_index<br />3表示使用寄存器的值 |
     |   EXTOp   |  O   |  2   | 扩展类型                              |
     |   ALUOp    |  O   |  8   | ALU操作                           |
     

9. CMP模块

   - 用于比较两个RegRD，输出在D级的跳转信号

     | 端口名 | I/O  | 位宽 | 用处     |
     | :----: | :--: | :--: | :------- |
     |   Op   |  I   |  4   | 操作类型 |
     |   I1   |  I   |  32  | 数据1    |
     |   I2   |  I   |  32  | 数据2    |
     |   O    |  O   |  1   | 是否跳转 |

10. 各级中间寄存器

   - 用于各级之间的参数转移。

11. 阻塞的操作

   - 锁住pc的值，使IF的pc不变。
   - 锁住IFtoID寄存器，使ID的情况不变。
   - reset IDtoEX寄存器，让CPU空转。

12. hazardControl模块

   - 获取各级的DegDst, DegSrc, RegWrite，得到各级的reg_AD, reg_AW
   - 比较各级信号，发出阻塞信号和转发结果
   - 把转发的MUX直接综合到hazardControl里面

以上是p5的内容，除此之外，本次CPU还需要几个模块来完成。

1. 乘除法模块

   - 存储HI，LO寄存器的值
   - 提供busy阻塞条件
   - ControlUnit发出MDWrite信号，表示对HI，LO的写入
2. MemByte模块

   - ControlUnit发出MemLen信号，表示Mem需要的字节类型，这里分成W(word)，H(half)，B(byte)

   - 根据MemA和MemLen信号来发出字节使能信号
   - 根据RegRD2来给出各字节写入的数据
3. MemExt模块

   - 根据MemA和MemLen信号来发出字节使能信号来获取写入的MemRD字节
   - 进行符号扩展，给出写入寄存器的正确数据
4. 删除了IFU和DM，改到tb中

## 测试方案

利用MARS构造样例，利用mips的逐行调试功能对比仿真过程中输出的结果对比来判断正确性。

利用课程的覆盖率工具检查疏漏

## 思考题

1. 乘除法需要较长的时间来完成，如果整合进ALU，会导致时钟周期过长。

2. 乘法可以使用流水线乘法器来完成，按照乘数逐位相乘左移并累加；

   除法会让除数左移和被除数对齐，然后依位相减左移，知道无法相减，得到商和余数

3. ControlUnit发出MDWrite信号，如果涉及到读取HILO寄存器并且E级在下一个周期任在计算,则阻塞

4. 使用字节使能，使得赋值过程更加清晰，避免了其他复杂的操作；每个S指令的存储方法被统一成相同形式的使能，更加普适，可扩展性强。

5. 不是，存储位宽小于4B的数据时

6. 在hazardControl中，利用RegDst和RegSrc对每一级的指令判断，用工程方法来消除复杂性

7. 新加入了HILO类指令的冲突，判断方式同思考题3

8. 依托课程组的Analysis来判断覆盖率，针对样例不足之处进行不断优化，测试较强

