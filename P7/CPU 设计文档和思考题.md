# CPU 设计文档和思考题

## CPU设计文档

1. 顶层设计
   	在logisim搭建的CPU中，将包含IFU，Splitter，Controller，GRF，ALU，DM，EXT。在其中进行合理的电路连接后，能够使其拥有解析指令的能力，完成单周期CPU。利用一个包含Controller的Control Unit来连接各个结构的输入端口和输出端口。

2. IFU

   - 可以使用多路选择器进行赋初值和异步复位

   - 使用寄存器实现PC，使用ROM实现

     | 端口名 | I/O  | 位宽 | 用处                 |
     | :----: | :--: | :--: | :------------------- |
     |  clk   |  I   |  1   | 时钟信号             |
     | reset  |  I   |  1   | 异步复位信号         |
     |  pcIn  |  I   |  32  | 计数器信号，用于写入 |
     | pcOut  |  O   |  32  | 计数器信号，用于输出 |
     | Instr  |  O   |  32  | 输出的指令           |
3. GRF

   - 32个寄存器，0号寄存器始终保持0，其余复位后均为0
   - 实现异步复位
     | 端口名 | I/O  | 位宽 | 用处                                        |
     | :----: | :--: | :--: | :------------------------------------------ |
     |  clk   |  I   |  1   | 时钟信号                                    |
     | reset  |  I   |  1   | 异步复位信号                                |
     |   WE   |  I   |  1   | 1表示可以向GRF中写入数据WD<br />0表示不写入 |
     |   A1   |  I   |  5   | 把A1寄存器的值读入RD1                       |
     |   A2   |  I   |  5   | 把A2寄存器的值读入RD2                       |
     |   A3   |  I   |  5   | 写入端口                       |
     |   WD   |  I   |  32  | 写入的数据                                  |
     |  RD1   |  O   |  32  | 输出RD1                                     |
     |  RD2   |  O   |  32  | 输出RD2                                     |
4. ALU

   - 提供加减乘除，位运算，大小比较和移位等运算
     
   - 这里考虑到ALU的可拓展性，Op选取了4位
     
     | 端口名 | I/O  | 位宽 | 用处     |
     | :----: | :--: | :--: | :------- |
     |   Op   |  I   |  8   | 操作类型 |
     |   I1   |  I   |  32  | 数据1    |
     |   I2   |  I   |  32  | 数据2    |
     |   O    |  O   |  32  | 运算结果 |
     
     | 操作名字 |  Op  |
     | :------: | :--: |
     |    +     |  0   |
     |    -     |  1   |
     |    \|     |  2   |
     |    <    |  3   |


5. DM

   - 实现异步复位

   - 加入写入和读取数据功能

   - 用12位来访问地址

     | 端口名 | I/O  | 位宽 |            用处            |
     | :----: | :--: | :--: | :------------------------- |
     |  clk   |  I   |  1   |          时钟信号          |
     | reset  |  I   |  1   |        异步复位信号        |
     |   WE   |  I   |  1   | 1表示可以向GRF中写入数据WD |
     |  WD   |  I   |  32  |          输入数据          |
     |   addr   |  I   |  32   |   访问的位置   |
     |  RD   |  O   |  32  |          输出数据           |

6. EXT

   - 将16位数据扩展到32位，实现0扩展和符号扩展

     | 端口名 | I/O  | 位宽 |      用处      |
     | :----: | :--: | :--: | :------------- |
     | Input |  I   |  16  | 输入的16位数据 |
     | EXTOp | I | 2 | 判断扩展类型<br />0为0扩展<br />1为符号扩展<br />2为左移16位 |
     | Output | O | 32 | 输出的32位数据 |

7. NPC

   - 作为PC的状态转移

     | 端口名 | I/O  | 位宽 |   用处   |
     | :----: | :--: | :--: | :------: |
     |   PC   |  I   |  32  |  当前PC  |
     |   Op   |  I   |  2   | 转换类型 |
     | PCNext |  O   |  32  | 下一个PC |


8. Controller

   - 获取Instr的前6位信号和后6位信号，输出操作类型

   - 先通过和逻辑来实现指令的判断，再通过或逻辑来生成操作
   
     |   端口名   | I/O  | 位宽 | 用处                                  |
     | :--------: | :--: | :--: | :------------------------------------ |
     |     Op     |  I   |  6   | 操作名                                |
     |    func    |  I   |  6   | R指令操作类型                         |
     |   RegDst   |  O   |  2   | 写入寄存器的位置<br />0表示16-20(I型)<br />1表示11-15(R型)<br />2表示$31(Jal) |
     |   ALUSrc   |  O   |  1   | 0表示ALU加寄存器的数<br />1表示立即数 |
     | RegSrc |  O   |  2   | 寄存器读写内存的值<br />0为ALU结果<br />1为Mem结果<br />2为PC的值 |
     | RegWrite |  O   |  1   | 寄存器读写<br />1表示可以写入         |
     |   MemWrite    |  O   |  1   | 内存读写<br />1表示可以写入           |
     |  NPCOp  |  O   |  2   | 0表示PC直接加4<br />1表示PC加offset<br />2表示使用Instr_index<br />3表示使用寄存器的值 |
     |   EXTOp   |  O   |  2   | 扩展类型                              |
     |   ALUOp    |  O   |  8   | ALU操作                           |
     

9. CMP模块

   - 用于比较两个RegRD，输出在D级的跳转信号

     | 端口名 | I/O  | 位宽 | 用处     |
     | :----: | :--: | :--: | :------- |
     |   Op   |  I   |  4   | 操作类型 |
     |   I1   |  I   |  32  | 数据1    |
     |   I2   |  I   |  32  | 数据2    |
     |   O    |  O   |  1   | 是否跳转 |

10. 各级中间寄存器

   - 用于各级之间的参数转移。

11. 阻塞的操作

   - 锁住pc的值，使IF的pc不变。
   - 锁住IFtoID寄存器，使ID的情况不变。
   - reset IDtoEX寄存器，让CPU空转。

12. hazardControl模块

   - 获取各级的DegDst, DegSrc, RegWrite，得到各级的reg_AD, reg_AW
   - 比较各级信号，发出阻塞信号和转发结果
   - 把转发的MUX直接综合到hazardControl里面

以上是p5的内容，除此之外，本次CPU还需要几个模块来完成。

1. 乘除法模块

   - 存储HI，LO寄存器的值
   - 提供busy阻塞条件
   - ControlUnit发出MDWrite信号，表示对HI，LO的写入
2. MemByte模块

   - ControlUnit发出MemLen信号，表示Mem需要的字节类型，这里分成W(word)，H(half)，B(byte)

   - 根据MemA和MemLen信号来发出字节使能信号
   - 根据RegRD2来给出各字节写入的数据
3. MemExt模块

   - 根据MemA和MemLen信号来发出字节使能信号来获取写入的MemRD字节
   - 进行符号扩展，给出写入寄存器的正确数据
4. 删除了IFU和DM，改到tb中

以上是p6的内容，除此之外，本次CPU还需要几个模块来完成。

1. CPU

   整合成一个外表为单周期CPU的样子，类似于P6中的mips模块

2. Bridge

   - 用于DM，IM，Timer和CPU相连。
   - 使mips整齐化

3. ExcCode信号

   - 各级流水线寄存器传递。
   - 分别由RegPC，ControlUnit，ALU，ByteEN来产生。

   - 优先处理先出现的错误，同一条指令优先处理第一个错误。

4. CP0

   - 位于M级
   - 存放异常中断相关寄存器，输出Req
   - 辅助完成异常处理程序

## 测试方案

利用MARS构造样例，利用mips的逐行调试功能对比仿真过程中输出的结果对比来判断正确性。

利用课程的覆盖率工具检查疏漏

## 思考题

1. 鼠标和键盘被按下后会发出一个中断信号，进入中断处理区的对应位置，若来不及响应，则会先置于缓存器。

2. 使结构统一化；可以；增加了硬件设计的复杂性和制作成本，可能因为客户的误操作而导致程序错误。

3. 系统桥来一次性给出CPU的输入输出信号，简单明了，符合高内聚，低耦合的设计思想。

4. 当到INT时，mode0为Enable置0，mode1为_IRQ置0

5. 空泡上不携带BD，PC的信息，导致EPC错误。BD，PC

6. 若该指令的延迟槽出现异常中断，则eret返回后跳转的PC和已经是改变后的PC+4了，和原来不一样，
